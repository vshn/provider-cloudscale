package objectsusercontroller

import (
	"context"
	"fmt"

	pipeline "github.com/ccremer/go-command-pipeline"
	cloudscalesdk "github.com/cloudscale-ch/cloudscale-go-sdk/v2"
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	"github.com/crossplane/crossplane-runtime/pkg/errors"
	"github.com/crossplane/crossplane-runtime/pkg/reconciler/managed"
	"github.com/crossplane/crossplane-runtime/pkg/resource"
	"github.com/vshn/provider-cloudscale/operator/pipelineutil"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/types"
	controllerruntime "sigs.k8s.io/controller-runtime"
)

// Observe implements managed.ExternalClient.
func (p *ObjectsUserPipeline) Observe(ctx context.Context, mg resource.Managed) (managed.ExternalObservation, error) {
	log := controllerruntime.LoggerFrom(ctx)
	log.V(1).Info("Observing resource")

	user := fromManaged(mg)
	if user.Status.AtProvider.UserID == "" {
		if userId, exists := user.Annotations[UserIDAnnotationKey]; exists {
			// get the user ID generated by Create() via annotation, since in Create() we're not allowed to update the status.
			user.Status.AtProvider.UserID = userId
			delete(user.Annotations, UserIDAnnotationKey) // might not work
		} else {
			// New resource, create user first
			return managed.ExternalObservation{}, nil
		}
	}

	pctx := &pipelineContext{Context: ctx, user: user}
	err := p.getObjectsUser(pctx)
	if err != nil {
		return managed.ExternalObservation{}, resource.Ignore(isNotFound, err)
	}

	csUser := pctx.csUser
	user.Status.AtProvider.Tags = fromTagMap(csUser.Tags)
	user.Status.AtProvider.DisplayName = csUser.DisplayName

	if tagsNeedUpdate(user.Spec.ForProvider.Tags, csUser.Tags) || user.GetDisplayName() != csUser.DisplayName {
		return managed.ExternalObservation{ResourceExists: true, ResourceUpToDate: false, ConnectionDetails: toConnectionDetails(csUser)}, nil
	}

	pipe := pipeline.NewPipeline[*pipelineContext]()
	result := pipe.WithBeforeHooks(pipelineutil.DebugLogger(pctx)).WithSteps(
		pipe.WithNestedSteps("observe credentials secret", hasSecretRef,
			pipe.NewStep("fetch credentials secret", p.fetchCredentialsSecret),
			pipe.NewStep("compare credentials", p.checkCredentials),
		).WithErrorHandler(p.observeCredentialsHandler),
	).RunWithContext(pctx)
	if result != nil {
		return managed.ExternalObservation{ResourceExists: true, ResourceUpToDate: false, ConnectionDetails: toConnectionDetails(csUser)}, nil
	}

	user.SetConditions(xpv1.Available())
	return managed.ExternalObservation{ResourceExists: true, ResourceUpToDate: true, ConnectionDetails: toConnectionDetails(csUser)}, nil
}

// getObjectsUser fetches an existing objects user from the project associated with the API token.
func (p *ObjectsUserPipeline) getObjectsUser(ctx *pipelineContext) error {
	csClient := p.csClient
	log := controllerruntime.LoggerFrom(ctx)

	csUser, err := csClient.ObjectsUsers.Get(ctx, ctx.user.Status.AtProvider.UserID)
	if err != nil {
		return err
	}
	ctx.csUser = csUser
	log.V(1).Info("Fetched objects user in cloudscale", "userID", csUser.ID, "displayName", csUser.DisplayName, "tags", csUser.Tags)
	return nil
}

func (p *ObjectsUserPipeline) fetchCredentialsSecret(ctx *pipelineContext) error {
	kube := p.kube
	secretRef := ctx.user.Spec.WriteConnectionSecretToReference
	ctx.credentialsSecret = &corev1.Secret{}

	return kube.Get(ctx, types.NamespacedName{Namespace: secretRef.Namespace, Name: secretRef.Name}, ctx.credentialsSecret)
}

func (p *ObjectsUserPipeline) checkCredentials(ctx *pipelineContext) error {
	secret := ctx.credentialsSecret
	data := secret.Data

	if len(data) == 0 {
		return fmt.Errorf("secret %q does not have any data", fmt.Sprintf("%s/%s", secret.Namespace, secret.Name))
	}

	for key, desired := range toConnectionDetails(ctx.csUser) {
		if observed, exists := data[key]; !exists || string(observed) != string(desired) {
			return fmt.Errorf("secret %q is missing on of the following keys or content: %s", fmt.Sprintf("%s/%s", secret.Namespace, secret.Name), key)
		}
	}
	return nil
}

func (p *ObjectsUserPipeline) observeCredentialsHandler(ctx *pipelineContext, err error) error {
	log := controllerruntime.LoggerFrom(ctx)
	if err != nil {
		log.V(1).Error(err, "Credentials Secret needs reconciling")
	}
	return nil
}

func isNotFound(err error) bool {
	var errResp *cloudscalesdk.ErrorResponse
	if errors.As(err, &errResp) {
		return errResp.StatusCode == 404
	}
	return false
}
